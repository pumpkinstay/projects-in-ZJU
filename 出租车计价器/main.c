/* Main.c file generated by New Project wizard
 *
 * Created:   Fri Jul 13 2018
 * Processor: AT89C51
 * Compiler:  Keil for 8051
 */

#include <reg51.h>
#include <intrins.h>
#include "i2c.h"

#define uchar unsigned char
#define uint unsigned int

#define I2C_SCL P3^0
#define I2C_SDA P3^1
#define I2C_DELAY 10

uint totalPrice,distance,timerCount,innerCount,waitPrice;
uint perPrice=9,startPrice=80;
uint running=0;
uint key1DownCount,key1UpCount,key2DownCount,key2UpCount,key1State,key2State,keyLock;
uchar minute;

uchar LedChar[] = {
   0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,
   0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71
};

uchar Position[]={0xfe,0xfd,0xfb,0xf7};

uchar show0,show1,show2,show3;

uchar perms,ms,second,minute;

sbit P00=P0^0;
sbit P01=P0^1;
sbit P02=P0^2;
sbit P03=P0^3;
sbit P04=P0^4;
sbit P05=P0^5;
sbit P06=P0^6;
sbit P07=P0^7;

sbit P20=P2^0;
sbit P21=P2^1;
sbit P22=P2^2;
sbit P23=P2^3;

sbit key0=P1^1;
sbit key1=P1^2;
sbit io_key_1=P1^3;
sbit io_key_2=P1^4;

sbit buzzer=P1^0;

sbit SCL=I2C_SCL;
sbit SDA=I2C_SDA;

static void i2c_delay(uint8 p_loop)
{
    while(p_loop--);
}

static void i2c_start()
{
    SDA=1;
    SCL=1;
    i2c_delay(I2C_DELAY);
    SDA=0;
    i2c_delay(I2C_DELAY);
    SCL=0;
}

static void i2c_stop()
{
    SDA=0;
    SCL=1;
    i2c_delay(I2C_DELAY);
    SDA=1;
    i2c_delay(I2C_DELAY);
}

static void i2c_send_ack(bool p_ack)
{
    SDA=p_ack;
    SCL=1;
    i2c_delay(I2C_DELAY);
    SCL=0;
    i2c_delay(I2C_DELAY);
}

static uint8 i2c_recv_ack()
{
    uint8 t_ack;
    SCL=1;
    i2c_delay(I2C_DELAY);
    t_ack=SDA;
    SCL=0;
    i2c_delay(I2C_DELAY);
    return t_ack;
}

static uint8 i2c_send_byte(uint8 p_data)
{
    uint8 t_i;
    for(t_i=0;t_i<8;t_i++)
    {
        SDA=p_data&0x80;
        p_data<<=1;
        SCL=1;
        i2c_delay(I2C_DELAY);
        SCL=0;
        i2c_delay(I2C_DELAY);
    }
    return i2c_recv_ack();
}

static uint8 i2c_recv_byte()
{
    uint8 t_i;
    uint8 t_data=0;
    SDA=1;
    for(t_i=0;t_i<8;t_i++)
    {
        t_data<<=1;
        SCL=1;
        i2c_delay(I2C_DELAY);
        t_data|=SDA;
        SCL=0;
        i2c_delay(I2C_DELAY);
    }
    return t_data;
}

void i2c_write(uint8 p_address,uint8 p_register,uint8 p_data)
{
    p_address<<=1;
    i2c_start();
    i2c_send_byte(p_address);
    i2c_send_byte(p_register);
    i2c_send_byte(p_data);
    i2c_stop();
}

uint8 i2c_read(uint8 p_address,uint8 p_register)
{
    uint8 t_data;
    i2c_multi_read(p_address,p_register,1,&t_data);
    return t_data;
}

void i2c_multi_write(uint8 p_address,uint8 p_register_start,uint8 p_count,uint8* p_buffer)
{
    uint8 t_i;
    for(t_i=0;t_i<p_count;t_i++)
        i2c_write(p_address,p_register_start+t_i,p_buffer[t_i]);
}

void i2c_multi_read(uint8 p_address,uint8 p_register_start,uint8 p_count,uint8* p_buffer)
{
    uint8 t_i;
    p_address<<=1;
    i2c_start();
    i2c_send_byte(p_address);
    i2c_send_byte(p_register_start);
    i2c_start();
    i2c_send_byte(p_address+1);
    for(t_i=0;t_i<p_count;t_i++)
    {
        p_buffer[t_i]=i2c_recv_byte();
        i2c_send_ack(t_i==p_count-1);
    }
    i2c_stop();
}

////////////////////////////////////////////
void delay(uint x)
{
   int i,j;
   for(i=x;i>0;i--)
      for(j=400;j>0;j--);
}
//////////////////////////////////////////////////
void delay_ms(uint16 p_ms)
{
    uint8 t_timer;
    while(p_ms--)
        for(t_timer=0;t_timer<250;t_timer++);
}

void realShow()
{
   
   P0=show0;
   P2=Position[0];
   delay(1);
   P0=0x00;
   
   P0=show1;
	 if(key1==0&&key0==1)
		P07=1;
   P2=Position[1];
   delay(1);
   P0=0x00;
   
   P0=show2;
	 if(key1==1)
   P07=1;
   P2=Position[2];
   delay(1);
   P0=0x00;
   
   P0=show3;
   P2=Position[3];
   delay(1);
   P0=0x00;
}

void timeDisplay()
{
   show0=LedChar[0];
   show1=LedChar[9];
   show2=LedChar[0];
   show3=LedChar[minute%10];
   
   realShow();
}

void totalPriceDisplay()
{
   show0=LedChar[totalPrice/1000];
   show1=LedChar[totalPrice%1000/100];
   show2=LedChar[totalPrice%100/10];
   show3=LedChar[totalPrice%10];
   
  realShow();
}

void startPriceDisplay()
{
   show0=LedChar[startPrice/1000];
   show1=LedChar[startPrice%1000/100];
   show2=LedChar[startPrice%100/10];
   show3=LedChar[startPrice%10];
   
   realShow();
}

void perPriceDisplay()
{
   show0=LedChar[perPrice/1000];
   show1=LedChar[perPrice%1000/100];
   show2=LedChar[perPrice%100/10];
   show3=LedChar[perPrice%10];
   
   realShow();
}

void priceCount()
{
   if(key0==1)
   {
      totalPrice=0;
   }
   else
   {
      if(distance<=4)
	 totalPrice=startPrice;
      else
	 totalPrice=startPrice+perPrice*(distance-4);
   }
   if(waitPrice>15)
   {
      totalPrice+=(waitPrice-15);
   }
   totalPrice%=10000;
}

void keyControl()
{ 
   if(io_key_1==0)
   {
      if(io_key_1==key1State)
	 key1DownCount++;
      else
	 key1DownCount=0;
   }
   if(key1DownCount>=10)
   {
      if(keyLock==0)
      {
	 keyLock=1;
	 perPrice++;
				innerCount=201;
      }
      key1DownCount=0;
   }

   
   if(io_key_1==1)
   {
      if(io_key_1==key1State&&keyLock==1)
	 key1UpCount++;
      else
	 key1UpCount=0;
   }
   if(key1UpCount>=20)
   {
      if(keyLock==1)
      {
	 keyLock=0;
      }
      key1UpCount=0;
   }
   
   if(io_key_2==0)
   {
      if(io_key_2==key2State)
	 key2DownCount++;
      else
	 key2DownCount=0;
   }
   if(key2DownCount>=10)
   {
      if(keyLock==0)
      {
	 keyLock=1;
	 if(perPrice>=2)
	    perPrice--;
	 innerCount=201;
      }
      key2DownCount=0;
   }

   
   if(io_key_2==1)
   {
      if(io_key_2==key2State&&keyLock==1)
	 key2UpCount++;
      else
	 key2UpCount=0;
   }
   if(key2UpCount>=20)
   {
      if(keyLock==1)
      {
	 keyLock=0;
      }
      key2UpCount=0;
   }
}

void init()
{
   distance=0;
   totalPrice=0;
   timerCount=0;
   waitPrice=0;
   innerCount=0;
   key1UpCount=0;
   key1DownCount=0;
   key2UpCount=0;
   key2DownCount=0;
   key1State=1;
   key2State=1;
   keyLock=0;
}


void main()
{
	 buzzer=0;
	perms=0;
   ms=0;
   second=0;
   minute=0;
///////////////////////////////////////////////
	 minute=i2c_read(0x50,0);
//////////////////////////////////////////////
   init();
   perPrice=9;
   startPrice=80;
   
   TL0=(65536-5)%256;
   TH0=(65536-5)/256;
   TMOD=0x06;
   EA=1;
   ET0=1;
   TR0=0;
   TH1=0xB8;
   TL1=0x00;
   TR1=1;
   
   while(1)
   {perms++;
      if(perms>=122)
      {
	 ms++;
	 perms=0;
      }
      if(ms>=14)
      {
	 second++;
	 ms=0;
      }
      if(second>=2)
      {
	 minute++;
	 second=0;
      }
      

      if(key0==1)
      {
	 if(running==1)
	 {
	    init();
	    buzzer=1;
	 }
	    
	 TR0=0;
	 running=0;
      }
      else
      {
	 if(running==0)
	 {
	    init();
	    buzzer=1;
	 }
	 
	 TR0=1;
	 running=1;
      }
      
      if(running==0)
      {
	 if(innerCount>=250)
	    buzzer=0;
	 
	 if(innerCount<=200)
	 {
		 if(key1==0)
			 timeDisplay();
		 else
	 startPriceDisplay();
		 
	 }
	    
	 else if(innerCount<=400)
		 {
		 if(key1==0)
			 timeDisplay();
		 else
	 perPriceDisplay();
		 
	 }
	 else
	    innerCount=0;
	 
	 keyControl();
      }
      else
      {
	 totalPriceDisplay();
	 if(innerCount>=100)
	    buzzer=0;
	 if(innerCount>=300)
	 {
	    timerCount=0;
	    waitPrice+=3;
	    innerCount=0;
	 }
      }
      
      if(TF1==1)
      {
	 TF1=0;
	 TH1=0xB8;
	 TL1=0x00;
	 innerCount++;
      }
       
      key1State=io_key_1;
      key2State=io_key_2;
      priceCount();
		////////////////////////////////////
	  i2c_write(0x50,0,minute);
		}
}

void Timer0() interrupt 1
{
   timerCount++;
   
   if(innerCount>=290)
      innerCount=0;
   
   if(timerCount>=5)
   {
      timerCount=0;
      distance++;
   }
}